<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Play: NawarOfThings</title>
    <link rel="stylesheet" href="/style.css" />
    <link rel="icon" href="./image/icon.jpg" type="image/x-icon" />
    <link href='style.css' rel='stylesheet'>
    <link href="https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css" rel="stylesheet">
    <style>
        body {
            height: 100vh;
            display: flex;
            justify-content: center; 
            align-items: center;
        }

        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <!-- Nav bar -->
    <nav>
        <a href="index" class="logo"><span>NawarOfThings</span></a>
        <ul class="links">
            <a href="index" class="link">Home</a>
            <a href="portfolio" class="link">Portfolio</a>
            <a href="play" class="link">Play!</a>
            <a href="contact" class="link">Contact</a>
        </ul>
        <i class='bx bx-menu' id="menu"></i>
    </nav>

    <div class="game-layout">
        <div id="game-sidebar">
            <h3><span>Games</span></h3>
            <button class="btn" id="btn-tetris">Tetris</button>
            <button class="btn" id="btn-snake">Snake</button>
            <button class="btn" id="btn-pong">Pong</button>
        </div>
        <div class="game-canvas-container">
            <canvas width="400" height="640" id="game"></canvas>
        </div>
    </div>

<script>
const canvas = document.getElementById('game');
const context = canvas.getContext('2d');
let currentGame = null;
let animationId = null;

// --- TETRIS LOGIC ---
function TetrisGame() {
    // ...Tetris variables and functions...
    const grid = 32;
    const tetrominoSequence = [];
    const playfield = [];
    for (let row = -2; row < 20; row++) {
        playfield[row] = [];
        for (let col = 0; col < 10; col++) {
            playfield[row][col] = 0;
        }
    }
    const tetrominos = {
        'I': [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
        'J': [[1,0,0],[1,1,1],[0,0,0]],
        'L': [[0,0,1],[1,1,1],[0,0,0]],
        'O': [[1,1],[1,1]],
        'S': [[0,1,1],[1,1,0],[0,0,0]],
        'Z': [[1,1,0],[0,1,1],[0,0,0]],
        'T': [[0,1,0],[1,1,1],[0,0,0]]
    };
    const colors = {
        'I': '#22223b',
        'O': '#ffd6a5',
        'T': '#393552',
        'S': '#a782e9',
        'Z': '#ffd6a5',
        'J': '#393552',
        'L': '#a782e9'
    };
    let count = 0;
    let tetromino = getNextTetromino();
    let rAF = null;
    let gameOver = false;

    function getRandomInt(min, max) {
        min = Math.ceil(min); max = Math.floor(max);
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    function generateSequence() {
        const sequence = ['I', 'J', 'L', 'O', 'S', 'T', 'Z'];
        while (sequence.length) {
            const rand = getRandomInt(0, sequence.length - 1);
            const name = sequence.splice(rand, 1)[0];
            tetrominoSequence.push(name);
        }
    }
    function getNextTetromino() {
        if (tetrominoSequence.length === 0) generateSequence();
        const name = tetrominoSequence.pop();
        const matrix = tetrominos[name];
        const col = playfield[0].length / 2 - Math.ceil(matrix[0].length / 2);
        const row = name === 'I' ? -1 : -2;
        return { name, matrix, row, col };
    }
    function rotate(matrix) {
        const N = matrix.length - 1;
        return matrix.map((row, i) => row.map((val, j) => matrix[N - j][i]));
    }
    function rotateLeft(matrix) {
        const N = matrix.length - 1;
        return matrix.map((row, i) => row.map((val, j) => matrix[j][N - i]));
    }
    function isValidMove(matrix, cellRow, cellCol) {
        for (let row = 0; row < matrix.length; row++) {
            for (let col = 0; col < matrix[row].length; col++) {
                if (matrix[row][col] && (
                    cellCol + col < 0 ||
                    cellCol + col >= playfield[0].length ||
                    cellRow + row >= playfield.length ||
                    playfield[cellRow + row][cellCol + col])
                ) return false;
            }
        }
        return true;
    }
    function placeTetromino() {
        for (let row = 0; row < tetromino.matrix.length; row++) {
            for (let col = 0; col < tetromino.matrix[row].length; col++) {
                if (tetromino.matrix[row][col]) {
                    if (tetromino.row + row < 0) return showGameOver();
                    playfield[tetromino.row + row][tetromino.col + col] = tetromino.name;
                }
            }
        }
        for (let row = playfield.length - 1; row >= 0; ) {
            if (playfield[row].every(cell => !!cell)) {
                for (let r = row; r >= 0; r--) {
                    for (let c = 0; c < playfield[r].length; c++) {
                        playfield[r][c] = playfield[r-1][c];
                    }
                }
            } else row--;
        }
        tetromino = getNextTetromino();
    }
    function showGameOver() {
        cancelAnimationFrame(rAF);
        gameOver = true;
        context.fillStyle = 'black';
        context.globalAlpha = 0.75;
        context.fillRect(0, canvas.height / 2 - 30, canvas.width, 60);
        context.globalAlpha = 1;
        context.fillStyle = 'white';
        context.font = '36px monospace';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillText('GAME OVER!', canvas.width / 2, canvas.height / 2);
    }
    function loop() {
        rAF = requestAnimationFrame(loop);
        context.clearRect(0,0,canvas.width,canvas.height);
        // draw playfield
        for (let row = 0; row < 20; row++) {
            for (let col = 0; col < 10; col++) {
                if (playfield[row][col]) {
                    const name = playfield[row][col];
                    context.fillStyle = colors[name];
                    context.fillRect(col * grid, row * grid, grid-1, grid-1);
                }
            }
        }
        // draw active tetromino
        if (tetromino) {
            if (++count > 35) {
                tetromino.row++;
                count = 0;
                if (!isValidMove(tetromino.matrix, tetromino.row, tetromino.col)) {
                    tetromino.row--;
                    placeTetromino();
                }
            }
            context.fillStyle = colors[tetromino.name];
            for (let row = 0; row < tetromino.matrix.length; row++) {
                for (let col = 0; col < tetromino.matrix[row].length; col++) {
                    if (tetromino.matrix[row][col]) {
                        context.fillRect((tetromino.col + col) * grid, (tetromino.row + row) * grid, grid-1, grid-1);
                    }
                }
            }
        }
    }
    function keydown(e) {
        if (gameOver) return;
        if (e.which === 37 || e.which === 39) {
            const col = e.which === 37 ? tetromino.col - 1 : tetromino.col + 1;
            if (isValidMove(tetromino.matrix, tetromino.row, col)) tetromino.col = col;
        }
        if (e.which === 38) {
            const matrix = rotate(tetromino.matrix);
            if (isValidMove(matrix, tetromino.row, tetromino.col)) tetromino.matrix = matrix;
        }
        if (e.which === 90) {
            const matrix = rotateLeft(tetromino.matrix);
            if (isValidMove(matrix, tetromino.row, tetromino.col)) tetromino.matrix = matrix;
        }
        if (e.which === 40) {
            const row = tetromino.row + 1;
            if (!isValidMove(tetromino.matrix, row, tetromino.col)) {
                tetromino.row = row - 1;
                placeTetromino();
                return;
            }
            tetromino.row = row;
        }
        if (e.which === 32) {
            while (isValidMove(tetromino.matrix, tetromino.row + 1, tetromino.col)) tetromino.row++;
            placeTetromino();
        }
        if (e.which === 82) {
            for (let row = -2; row < 20; row++) {
                playfield[row] = [];
                for (let col = 0; col < 10; col++) playfield[row][col] = 0;
            }
            tetrominoSequence.length = 0;
            tetromino = getNextTetromino();
            gameOver = false;
            count = 0;
            cancelAnimationFrame(rAF);
            rAF = requestAnimationFrame(loop);
        }
    }
    this.start = function() {
        canvas.width = 320; canvas.height = 640;
        document.addEventListener('keydown', keydown);
        rAF = requestAnimationFrame(loop);
    }
    this.stop = function() {
        cancelAnimationFrame(rAF);
        document.removeEventListener('keydown', keydown);
    }
}

// --- SNAKE LOGIC ---
function SnakeGame() {
    let grid = 16, count = 0;
    let snake = { x: 160, y: 160, dx: grid, dy: 0, cells: [], maxCells: 4 };
    let apple = { x: 320, y: 320 };
    let rAF = null;
    function getRandomInt(min, max) {
        return Math.floor(Math.random() * (max - min)) + min;
    }
    function loop() {
        rAF = requestAnimationFrame(loop);
        if (++count < 4) return;
        count = 0;
        context.clearRect(0,0,canvas.width,canvas.height);
        snake.x += snake.dx; snake.y += snake.dy;
        if (snake.x < 0) snake.x = canvas.width - grid;
        else if (snake.x >= canvas.width) snake.x = 0;
        if (snake.y < 0) snake.y = canvas.height - grid;
        else if (snake.y >= canvas.height) snake.y = 0;
        snake.cells.unshift({x: snake.x, y: snake.y});
        if (snake.cells.length > snake.maxCells) snake.cells.pop();
        context.fillStyle = '#393552';
        context.fillRect(apple.x, apple.y, grid-1, grid-1);
        context.fillStyle = '#a782e9';
        snake.cells.forEach(function(cell, index) {
            context.fillRect(cell.x, cell.y, grid-1, grid-1);
            if (cell.x === apple.x && cell.y === apple.y) {
                snake.maxCells++;
                apple.x = getRandomInt(0, 25) * grid;
                apple.y = getRandomInt(0, 25) * grid;
            }
            for (let i = index + 1; i < snake.cells.length; i++) {
                if (cell.x === snake.cells[i].x && cell.y === snake.cells[i].y) {
                    snake.x = 160; snake.y = 160; snake.cells = [];
                    snake.maxCells = 4; snake.dx = grid; snake.dy = 0;
                    apple.x = getRandomInt(0, 25) * grid;
                    apple.y = getRandomInt(0, 25) * grid;
                }
            }
        });
    }
    function keydown(e) {
        if (e.which === 37 && snake.dx === 0) { snake.dx = -grid; snake.dy = 0; }
        else if (e.which === 38 && snake.dy === 0) { snake.dy = -grid; snake.dx = 0; }
        else if (e.which === 39 && snake.dx === 0) { snake.dx = grid; snake.dy = 0; }
        else if (e.which === 40 && snake.dy === 0) { snake.dy = grid; snake.dx = 0; }
    }
    this.start = function() {
        canvas.width = 400; canvas.height = 400;
        document.addEventListener('keydown', keydown);
        rAF = requestAnimationFrame(loop);
    }
    this.stop = function() {
        cancelAnimationFrame(rAF);
        document.removeEventListener('keydown', keydown);
    }
}

// --- PONG LOGIC ---
function PongGame() {
    const grid = 15;
    const paddleHeight = grid * 10;
    const maxPaddleY = 585 - grid - paddleHeight;
    let paddleSpeed = 12, ballSpeed = 5;
    const leftPaddle = { x: grid * 2, y: 292.5 - paddleHeight / 2, width: grid, height: paddleHeight, dy: 0 };
    const rightPaddle = { x: 585 - grid * 3, y: 292.5 - paddleHeight / 2, width: grid, height: paddleHeight, dy: 0 };
    const ball = { x: 292.5, y: 292.5, width: grid, height: grid, resetting: false, dx: ballSpeed, dy: -ballSpeed };
    let rAF = null;
    function collides(obj1, obj2) {
        return obj1.x < obj2.x + obj2.width &&
               obj1.x + obj1.width > obj2.x &&
               obj1.y < obj2.y + obj2.height &&
               obj1.y + obj1.height > obj2.y;
    }
    function loop() {
        rAF = requestAnimationFrame(loop);
        context.clearRect(0,0,585,585);
        leftPaddle.y += leftPaddle.dy;
        rightPaddle.y += rightPaddle.dy;
        if (leftPaddle.y < grid) leftPaddle.y = grid;
        else if (leftPaddle.y > maxPaddleY) leftPaddle.y = maxPaddleY;
        if (rightPaddle.y < grid) rightPaddle.y = grid;
        else if (rightPaddle.y > maxPaddleY) rightPaddle.y = maxPaddleY;
        context.fillStyle = '#a782e9';
        context.fillRect(leftPaddle.x, leftPaddle.y, leftPaddle.width, leftPaddle.height);
        context.fillRect(rightPaddle.x, rightPaddle.y, rightPaddle.width, rightPaddle.height);
        ball.x += ball.dx; ball.y += ball.dy;
        if (ball.y < grid) { ball.y = grid; ball.dy *= -1; }
        else if (ball.y + grid > 585 - grid) { ball.y = 585 - grid * 2; ball.dy *= -1; }
        if ((ball.x < 0 || ball.x > 585) && !ball.resetting) {
            ball.resetting = true;
            setTimeout(() => {
                ball.resetting = false;
                ball.x = 292.5; ball.y = 292.5;
            }, 400);
        }
        if (collides(ball, leftPaddle)) { ball.dx *= -1; ball.x = leftPaddle.x + leftPaddle.width; }
        else if (collides(ball, rightPaddle)) { ball.dx *= -1; ball.x = rightPaddle.x - ball.width; }
        context.fillRect(ball.x, ball.y, ball.width, ball.height);
        context.fillStyle = '#393552';
        context.fillRect(0, 0, 585, grid);
        context.fillRect(0, 585 - grid, 585, 585);
        for (let i = grid; i < 585 - grid; i += grid * 2) {
            context.fillRect(585 / 2 - grid / 2, i, grid, grid);
        }
    }
    function keydown(e) {
        if (e.which === 38) rightPaddle.dy = -paddleSpeed;
        else if (e.which === 40) rightPaddle.dy = paddleSpeed;
        if (e.which === 87) leftPaddle.dy = -paddleSpeed;
        else if (e.which === 83) leftPaddle.dy = paddleSpeed;
    }
    function keyup(e) {
        if (e.which === 38 || e.which === 40) rightPaddle.dy = 0;
        if (e.which === 83 || e.which === 87) leftPaddle.dy = 0;
    }
    this.start = function() {
        canvas.width = 585; canvas.height = 585;
        document.addEventListener('keydown', keydown);
        document.addEventListener('keyup', keyup);
        rAF = requestAnimationFrame(loop);
    }
    this.stop = function() {
        cancelAnimationFrame(rAF);
        document.removeEventListener('keydown', keydown);
        document.removeEventListener('keyup', keyup);
    }
}

// --- GAME SWITCHING LOGIC ---
function switchGame(gameName) {
    if (currentGame) currentGame.stop();
    context.clearRect(0, 0, canvas.width, canvas.height);
    if (gameName === 'tetris') currentGame = new TetrisGame();
    else if (gameName === 'snake') currentGame = new SnakeGame();
    else if (gameName === 'pong') currentGame = new PongGame();
    currentGame.start();
}

// Sidebar button events
document.getElementById('btn-tetris').onclick = () => switchGame('tetris');
document.getElementById('btn-snake').onclick = () => switchGame('snake');
document.getElementById('btn-pong').onclick = () => switchGame('pong');

// Start with Tetris by default
switchGame('tetris');
</script>
</body>
</html>